module Stats
  class Aggregator
    def initialize(authorization_requests=nil)
      @authorization_requests = authorization_requests || AuthorizationRequest.all
    end

    def average_time_to_submit
      authorizations_with_first_create_and_submit_events.average("EXTRACT(EPOCH FROM (first_submit_events.event_time - first_create_events.event_time))")
    end

    def median_time_to_submit
      calculate_percentile(authorizations_with_first_create_and_submit_events, time_difference_sql('first_submit_events', 'first_create_events'))
    end

    def stddev_time_to_submit
      calculate_stddev(authorizations_with_first_create_and_submit_events, time_difference_sql('first_submit_events', 'first_create_events'))
    end

    def mode_time_to_submit
      calculate_mode(authorizations_with_first_create_and_submit_events, time_difference_sql('first_submit_events', 'first_create_events'), 60)
    end

    def average_time_to_first_instruction
      authorizations_with_submit_and_first_instruction_events.average("EXTRACT(EPOCH FROM (first_instruction_events.event_time - submit_events.event_time))")
    end

    def median_time_to_first_instruction
      calculate_percentile(authorizations_with_submit_and_first_instruction_events, time_difference_sql('first_instruction_events', 'submit_events'))
    end

    def stddev_time_to_first_instruction
      calculate_stddev(authorizations_with_submit_and_first_instruction_events, time_difference_sql('first_instruction_events', 'submit_events'))
    end

    def mode_time_to_first_instruction
      calculate_mode(authorizations_with_submit_and_first_instruction_events, time_difference_sql('first_instruction_events', 'submit_events'), 86400)
    end

    def first_create_events_subquery
      # We ignore the legacy AuthorizationRequestChangelog as they are inconsistent data generated by the migration from v1
      first_event_subquery('create')
        .joins("LEFT JOIN authorization_request_changelogs ON authorization_request_events.entity_type = 'AuthorizationRequestChangelog' AND authorization_request_events.entity_id = authorization_request_changelogs.id")
        .where("authorization_request_changelogs.legacy IS NULL OR authorization_request_changelogs.legacy = false")
    end

    def reopen_events_count
      # Find reopen events for the authorization requests
      authorization_request_ids = @authorization_requests.pluck(:id)
      
      reopen_events = AuthorizationRequestEvent
        .where(name: 'reopen')
        .where(authorization_request_id: authorization_request_ids)
        .select(:id, :authorization_request_id, :created_at)

      # Count only those reopens that have a subsequent submit event
      reopen_events.select do |reopen_event|
        AuthorizationRequestEvent
          .where(name: 'submit')
          .where(authorization_request_id: reopen_event.authorization_request_id)
          .where('created_at > ?', reopen_event.created_at)
          .exists?
      end.count
    end

    def validated_events_count(date_range)
      # Count approve events for the authorization requests in the date range
      authorization_request_ids = @authorization_requests.pluck(:id)
      
      AuthorizationRequestEvent
        .where(name: 'approve')
        .where(authorization_request_id: authorization_request_ids)
        .where(created_at: date_range)
        .count
    end

    def refused_events_count(date_range)
      # Count refuse events for the authorization requests in the date range
      authorization_request_ids = @authorization_requests.pluck(:id)
      
      AuthorizationRequestEvent
        .where(name: 'refuse')
        .where(authorization_request_id: authorization_request_ids)
        .where(created_at: date_range)
        .count
    end

    def volume_by_type
      @authorization_requests
        .group(:type)
        .count
        .map { |type, count| { type: type, count: count } }
        .sort_by { |item| -item[:count] }
    end

    def volume_by_provider
      # Get all authorization requests with their types
      type_counts = @authorization_requests.group(:type).count
      
      # Group by provider
      provider_counts = Hash.new(0)
      
      type_counts.each do |type, count|
        # Get the definition for this type
        definition = AuthorizationDefinition.all.find do |def_item|
          def_item.authorization_request_class_as_string == type
        end
        
        if definition && definition.provider
          provider_name = definition.provider.name
          provider_counts[provider_name] += count
        else
          # If no provider found, use the type name as fallback
          provider_counts[type] += count
        end
      end
      
      provider_counts.map { |provider, count| { provider: provider, count: count } }
        .sort_by { |item| -item[:count] }
    end

    def volume_by_type_with_states
      # Get counts for validated and refused states only
      validated_refused = @authorization_requests
        .where(state: ['validated', 'refused'])
        .group(:type, :state)
        .count
      
      # Organize by type
      by_type = Hash.new { |h, k| h[k] = { validated: 0, refused: 0 } }
      
      validated_refused.each do |(type, state), count|
        by_type[type][state.to_sym] = count
      end
      
      # Convert to array and calculate totals
      by_type.map do |type, states|
        {
          type: type,
          validated: states[:validated],
          refused: states[:refused],
          total: states[:validated] + states[:refused]
        }
      end.sort_by { |item| -item[:total] }
    end

    def volume_by_provider_with_states
      # Get counts for validated and refused states only
      validated_refused = @authorization_requests
        .where(state: ['validated', 'refused'])
        .group(:type, :state)
        .count
      
      # Group by provider
      by_provider = Hash.new { |h, k| h[k] = { validated: 0, refused: 0 } }
      
      validated_refused.each do |(type, state), count|
        # Get the definition for this type
        definition = AuthorizationDefinition.all.find do |def_item|
          def_item.authorization_request_class_as_string == type
        end
        
        provider_name = if definition && definition.provider
          definition.provider.name
        else
          type
        end
        
        by_provider[provider_name][state.to_sym] += count
      end
      
      # Convert to array and calculate totals
      by_provider.map do |provider, states|
        {
          provider: provider,
          validated: states[:validated],
          refused: states[:refused],
          total: states[:validated] + states[:refused]
        }
      end.sort_by { |item| -item[:total] }
    end

    def time_to_submit_by_type
      results = authorizations_with_first_create_and_submit_events
        .group("authorization_requests.type")
        .order(Arel.sql("AVG(EXTRACT(EPOCH FROM (first_submit_events.event_time - first_create_events.event_time)))"))
        .pluck(
          Arel.sql("authorization_requests.type"),
          Arel.sql("MIN(EXTRACT(EPOCH FROM (first_submit_events.event_time - first_create_events.event_time)))"),
          Arel.sql("AVG(EXTRACT(EPOCH FROM (first_submit_events.event_time - first_create_events.event_time)))"),
          Arel.sql("MAX(EXTRACT(EPOCH FROM (first_submit_events.event_time - first_create_events.event_time)))"),
          Arel.sql("COUNT(*)")
        )
      
      results.map do |type, min_time, avg_time, max_time, count|
        {
          type: type,
          min_time: min_time&.to_f,
          avg_time: avg_time&.to_f,
          max_time: max_time&.to_f,
          count: count
        }
      end
    end

    def time_to_submit_by_duration_buckets(step: :day)
      time_values = authorizations_with_first_create_and_submit_events
        .pluck(Arel.sql("EXTRACT(EPOCH FROM (first_submit_events.event_time - first_create_events.event_time))"))
        .map(&:to_f)
      
      create_duration_buckets(time_values, step)
    end

    def time_to_first_instruction_by_duration_buckets(step: :day)
      time_values = authorizations_with_submit_and_first_instruction_events
        .pluck(Arel.sql("EXTRACT(EPOCH FROM (first_instruction_events.event_time - submit_events.event_time))"))
        .map(&:to_f)
      
      create_duration_buckets(time_values, step)
    end

    def median_time_to_submit_by_type
      calculate_median_by_type(
        authorizations_with_first_create_and_submit_events,
        time_difference_sql('first_submit_events', 'first_create_events')
      )
    end

    def median_time_to_first_instruction_by_type
      calculate_median_by_type(
        authorizations_with_submit_and_first_instruction_events,
        time_difference_sql('first_instruction_events', 'submit_events')
      )
    end

    def average_time_to_production_instruction
      authorizations_with_start_next_stage_and_production_instruction_events.average("EXTRACT(EPOCH FROM (first_production_instruction_events.event_time - start_next_stage_events.event_time))")
    end

    def median_time_to_production_instruction
      calculate_percentile(authorizations_with_start_next_stage_and_production_instruction_events, time_difference_sql('first_production_instruction_events', 'start_next_stage_events'))
    end

    def stddev_time_to_production_instruction
      calculate_stddev(authorizations_with_start_next_stage_and_production_instruction_events, time_difference_sql('first_production_instruction_events', 'start_next_stage_events'))
    end

    def mode_time_to_production_instruction
      calculate_mode(authorizations_with_start_next_stage_and_production_instruction_events, time_difference_sql('first_production_instruction_events', 'start_next_stage_events'), 86400)
    end

    def median_time_to_production_instruction_by_type
      calculate_median_by_type(
        authorizations_with_start_next_stage_and_production_instruction_events,
        time_difference_sql('first_production_instruction_events', 'start_next_stage_events')
      )
    end

    def time_to_production_instruction_by_duration_buckets(step: :day)
      time_values = authorizations_with_start_next_stage_and_production_instruction_events
        .pluck(Arel.sql("EXTRACT(EPOCH FROM (first_production_instruction_events.event_time - start_next_stage_events.event_time))"))
        .map(&:to_f)
      
      create_duration_buckets(time_values, step)
    end

    private

    def time_difference_sql(later_event, earlier_event)
      "EXTRACT(EPOCH FROM (#{later_event}.event_time - #{earlier_event}.event_time))"
    end

    def calculate_percentile(scope, time_expression)
      result = scope
        .pluck(Arel.sql("PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY #{time_expression})"))
        .first
      
      result&.to_f
    end

    def calculate_stddev(scope, time_expression)
      result = scope
        .pluck(Arel.sql("STDDEV_POP(#{time_expression})"))
        .first
      
      result&.to_f
    end

    def calculate_mode(scope, time_expression, rounding_unit)
      time_values = scope
        .pluck(Arel.sql("CEIL(#{time_expression} / #{rounding_unit}) * #{rounding_unit}"))
        .map(&:to_f)
      
      return nil if time_values.empty?
      
      frequency = time_values.group_by(&:itself).transform_values(&:count)
      frequency.max_by { |_, count| count }&.first
    end

    def create_duration_buckets(time_values, step)
      return [] if time_values.empty?
      
      step_config = step_configuration(step)
      step_seconds = step_config[:seconds]
      max_steps = step_config[:max_steps]
      
      buckets = initialize_buckets(max_steps)
      distribute_values_into_buckets(buckets, time_values, step_seconds, max_steps)
      format_buckets_as_array(buckets, max_steps)
    end

    def initialize_buckets(max_steps)
      buckets = { "<1" => 0 }
      (1..max_steps).each { |i| buckets[i.to_s] = 0 }
      buckets["> #{max_steps}"] = 0
      buckets
    end

    def distribute_values_into_buckets(buckets, time_values, step_seconds, max_steps)
      time_values.each do |seconds|
        bucket_index = (seconds / step_seconds).ceil
        
        if bucket_index < 1
          buckets["<1"] += 1
        elsif bucket_index > max_steps
          buckets["> #{max_steps}"] += 1
        else
          buckets[bucket_index.to_s] += 1
        end
      end
    end

    def format_buckets_as_array(buckets, max_steps)
      result = [{ bucket: "<1", count: buckets["<1"] }]
      (1..max_steps).each { |i| result << { bucket: i.to_s, count: buckets[i.to_s] } }
      result << { bucket: "> #{max_steps}", count: buckets["> #{max_steps}"] }
      result
    end

    def calculate_median_by_type(scope, time_expression)
      results = scope.pluck(
        Arel.sql("authorization_requests.type"),
        Arel.sql(time_expression)
      )
      
      by_type = Hash.new { |h, k| h[k] = [] }
      results.each { |type, time| by_type[type] << time.to_f }
      
      by_type.map do |type, times|
        {
          type: type,
          median_time: calculate_array_median(times),
          count: times.length
        }
      end.sort_by { |item| item[:median_time] }
    end

    def calculate_array_median(sorted_values)
      sorted = sorted_values.sort
      if sorted.length.odd?
        sorted[sorted.length / 2]
      else
        (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2.0
      end
    end

    def step_configuration(step)
      case step
      when :minute
        { seconds: 60, max_steps: 60 }
      when :hour
        { seconds: 3600, max_steps: 24 }
      when :day
        { seconds: 86400, max_steps: 30 }
      else
        raise ArgumentError, "Invalid step: #{step}. Must be :minute, :hour, or :day"
      end
    end

    def first_submit_events_subquery
      # We ignore the legacy AuthorizationRequestChangelog as they are inconsistent data generated by the migration from v1
      first_event_subquery('submit')
        .joins("LEFT JOIN authorization_request_changelogs ON authorization_request_events.entity_type = 'AuthorizationRequestChangelog' AND authorization_request_events.entity_id = authorization_request_changelogs.id")
        .where("authorization_request_changelogs.legacy IS NULL OR authorization_request_changelogs.legacy = false")
    end

    def first_event_subquery(event_name)
      AuthorizationRequestEvent
        .where(name: event_name)
        .where.not(authorization_request_id: nil)
        .group("authorization_request_events.authorization_request_id")
        .select("authorization_request_events.authorization_request_id, MIN(authorization_request_events.created_at) as event_time")
    end

    def authorizations_with_first_create_and_submit_events
      @authorization_requests
        .joins("INNER JOIN (#{first_create_events_subquery.to_sql}) first_create_events ON first_create_events.authorization_request_id = authorization_requests.id")
        .joins("INNER JOIN (#{first_submit_events_subquery.to_sql}) first_submit_events ON first_submit_events.authorization_request_id = authorization_requests.id")
        .where("first_submit_events.event_time >= first_create_events.event_time") # we have one case where the submit event is before the create event, so we need to filter it out
    end

    def authorizations_with_submit_and_first_instruction_events
      @authorization_requests
        .joins("INNER JOIN (#{submit_events_subquery.to_sql}) submit_events ON submit_events.authorization_request_id = authorization_requests.id")
        .joins("INNER JOIN (#{first_instruction_events_subquery.to_sql}) first_instruction_events ON first_instruction_events.authorization_request_id = authorization_requests.id AND first_instruction_events.submit_event_id = submit_events.event_id")
        .where("first_instruction_events.event_time > submit_events.event_time")
    end

    def submit_events_subquery
      AuthorizationRequestEvent
        .where(name: 'submit')
        .where.not(authorization_request_id: nil)
        .select("authorization_request_events.id as event_id, authorization_request_events.authorization_request_id, authorization_request_events.created_at as event_time")
    end

    def first_instruction_events_subquery
      # For each submit event, find the first instruction event (approve, refuse, or request_changes) that follows it
      AuthorizationRequestEvent
        .from("authorization_request_events AS instruction_events")
        .joins("INNER JOIN authorization_request_events AS submit_events ON instruction_events.authorization_request_id = submit_events.authorization_request_id")
        .where("submit_events.name = 'submit'")
        .where("instruction_events.name IN ('approve', 'refuse', 'request_changes')")
        .where("instruction_events.created_at > submit_events.created_at")
        .group("instruction_events.authorization_request_id, submit_events.id")
        .select(
          "instruction_events.authorization_request_id",
          "submit_events.id as submit_event_id",
          "MIN(instruction_events.created_at) as event_time"
        )
    end

    def production_authorization_requests
      # Filter authorization requests that are production types
      production_types = AuthorizationDefinition.all.select do |def_item|
        def_item.stage.exists? && def_item.stage.type == 'production'
      end.map(&:authorization_request_class_as_string)
      
      @authorization_requests.where(type: production_types)
    end

    def first_start_next_stage_events_subquery
      # Find the first start_next_stage event for each authorization request using DISTINCT ON
      # We need to use raw SQL because we need both the id and the min created_at
      sql = <<-SQL.squish
        SELECT DISTINCT ON (authorization_request_events.authorization_request_id)
          authorization_request_events.id as event_id,
          authorization_request_events.authorization_request_id,
          authorization_request_events.created_at as event_time
        FROM authorization_request_events
        WHERE authorization_request_events.name = 'start_next_stage'
          AND authorization_request_events.authorization_request_id IS NOT NULL
        ORDER BY authorization_request_events.authorization_request_id, authorization_request_events.created_at ASC
      SQL
      
      AuthorizationRequestEvent.from("(#{sql}) AS start_next_stage_events")
        .select("start_next_stage_events.event_id, start_next_stage_events.authorization_request_id, start_next_stage_events.event_time")
    end

    def authorizations_with_start_next_stage_and_production_instruction_events
      production_authorization_requests
        .joins("INNER JOIN (#{first_start_next_stage_events_subquery.to_sql}) start_next_stage_events ON start_next_stage_events.authorization_request_id = authorization_requests.id")
        .joins("INNER JOIN (#{first_production_instruction_events_subquery.to_sql}) first_production_instruction_events ON first_production_instruction_events.authorization_request_id = authorization_requests.id AND first_production_instruction_events.start_next_stage_event_id = start_next_stage_events.event_id")
        .where("first_production_instruction_events.event_time > start_next_stage_events.event_time")
    end

    def first_production_instruction_events_subquery
      # For each start_next_stage event, find the first instruction event (approve, refuse, or request_changes) that follows it
      AuthorizationRequestEvent
        .from("authorization_request_events AS instruction_events")
        .joins("INNER JOIN authorization_request_events AS start_next_stage_events ON instruction_events.authorization_request_id = start_next_stage_events.authorization_request_id")
        .where("start_next_stage_events.name = 'start_next_stage'")
        .where("instruction_events.name IN ('approve', 'refuse', 'request_changes')")
        .where("instruction_events.created_at > start_next_stage_events.created_at")
        .group("instruction_events.authorization_request_id, start_next_stage_events.id")
        .select(
          "instruction_events.authorization_request_id",
          "start_next_stage_events.id as start_next_stage_event_id",
          "MIN(instruction_events.created_at) as event_time"
        )
    end
  end
end
